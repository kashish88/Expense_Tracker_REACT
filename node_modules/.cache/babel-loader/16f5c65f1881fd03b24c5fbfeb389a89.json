{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst types_1 = require(\"./types\");\n\nconst token_1 = require(\"./token\");\n\nconst StartEventJSON = JSON.stringify({\n  event: 'start'\n});\nconst StopEventJSON = JSON.stringify({\n  event: 'stop'\n});\n\nclass WebsocketClient {\n  constructor(loginUrl, apiUrl, languageCode, sampleRate) {\n    this.startCbs = [];\n    this.stopCbs = [];\n\n    this.onResponseCb = () => {};\n\n    this.onCloseCb = () => {};\n\n    this.onWebsocketMessage = event => {\n      let response;\n\n      try {\n        response = JSON.parse(event.data);\n      } catch (e) {\n        console.error('[SpeechlyClient] Error parsing response from the server:', e);\n        return;\n      }\n\n      switch (response.type) {\n        case types_1.WebsocketResponseType.Started:\n          this.startCbs.forEach(cb => {\n            try {\n              cb(undefined, response.audio_context);\n            } catch (e) {\n              console.error('[SpeechlyClient] Error while invoking \"onStart\" callback:', e);\n            }\n          });\n          this.startCbs.length = 0;\n          break;\n\n        case types_1.WebsocketResponseType.Stopped:\n          this.stopCbs.forEach(cb => {\n            try {\n              cb(undefined, response.audio_context);\n            } catch (e) {\n              console.error('[SpeechlyClient] Error while invoking \"onStop\" callback:', e);\n            }\n          });\n          this.stopCbs.length = 0;\n          break;\n\n        default:\n          this.onResponseCb(response);\n      }\n    };\n\n    this.onWebsocketClose = event => {\n      this.websocket = undefined;\n      this.onCloseCb(Error(`Websocket was closed with code \"${event.code}\" and reason \"${event.reason}\"`));\n    };\n\n    this.onWebsocketError = _event => {\n      this.closeWebsocket(1000, 'Client disconnecting due to an error');\n      this.onCloseCb(Error('Websocket was closed because of error'));\n    };\n\n    this.loginUrl = loginUrl;\n    this.apiUrl = generateWsUrl(apiUrl, languageCode, sampleRate);\n  }\n\n  onResponse(cb) {\n    this.onResponseCb = cb;\n  }\n\n  onClose(cb) {\n    this.onCloseCb = cb;\n  }\n\n  initialize(appId, deviceId, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.websocket !== undefined) {\n        throw Error('Cannot initialize an already initialized websocket client');\n      }\n\n      if (token !== undefined && token_1.validateToken(token, appId, deviceId)) {\n        // If the token is still valid, don't refresh it.\n        this.authToken = token;\n      } else {\n        this.authToken = yield token_1.fetchToken(this.loginUrl, appId, deviceId);\n      }\n\n      this.websocket = yield initializeWebsocket(this.apiUrl, this.authToken);\n      this.websocket.addEventListener('message', this.onWebsocketMessage);\n      this.websocket.addEventListener('error', this.onWebsocketError);\n      this.websocket.addEventListener('close', this.onWebsocketClose);\n      return this.authToken;\n    });\n  }\n\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.closeWebsocket(1000, 'Client has ended the session');\n    });\n  }\n\n  startContext() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isOpen()) {\n        throw Error('Websocket is not ready');\n      }\n\n      const ws = this.websocket;\n      return new Promise((resolve, reject) => {\n        this.startCbs.push((err, id) => {\n          if (err !== undefined) {\n            reject(err);\n          } else {\n            resolve(id);\n          }\n        });\n        ws.send(StartEventJSON);\n      });\n    });\n  }\n\n  stopContext() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isOpen()) {\n        throw Error('Websocket is not ready');\n      }\n\n      const ws = this.websocket;\n      return new Promise((resolve, reject) => {\n        this.stopCbs.push((err, id) => {\n          if (err !== undefined) {\n            reject(err);\n          } else {\n            resolve(id);\n          }\n        });\n        ws.send(StopEventJSON);\n      });\n    });\n  }\n\n  sendAudio(audioChunk) {\n    if (!this.isOpen()) {\n      return Error('Cannot send data through inactive websocket');\n    }\n\n    const ws = this.websocket;\n    ws.send(audioChunk);\n  }\n\n  isOpen() {\n    return this.websocket !== undefined && this.websocket.readyState === this.websocket.OPEN;\n  }\n\n  closeWebsocket(code, message) {\n    if (this.websocket === undefined) {\n      throw Error('Websocket is not open');\n    }\n\n    this.websocket.removeEventListener('message', this.onWebsocketMessage);\n    this.websocket.removeEventListener('error', this.onWebsocketError);\n    this.websocket.removeEventListener('close', this.onWebsocketClose);\n    this.websocket.close(code, message);\n    this.websocket = undefined;\n  }\n\n}\n\nexports.WebsocketClient = WebsocketClient;\n\nfunction generateWsUrl(baseUrl, languageCode, sampleRate) {\n  const params = new URLSearchParams();\n  params.append('languageCode', languageCode);\n  params.append('sampleRate', sampleRate.toString());\n  return `${baseUrl}?${params.toString()}`;\n}\n\nfunction initializeWebsocket(url, protocol) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const ws = new WebSocket(url, protocol);\n    return new Promise((resolve, reject) => {\n      const errhandler = () => {\n        ws.removeEventListener('close', errhandler);\n        ws.removeEventListener('error', errhandler);\n        ws.removeEventListener('open', openhandler);\n        reject(Error('Connection failed'));\n      };\n\n      const openhandler = () => {\n        ws.removeEventListener('close', errhandler);\n        ws.removeEventListener('error', errhandler);\n        ws.removeEventListener('open', openhandler);\n        resolve(ws);\n      };\n\n      ws.addEventListener('close', errhandler);\n      ws.addEventListener('error', errhandler);\n      ws.addEventListener('open', openhandler);\n    });\n  });\n}","map":{"version":3,"sources":["../../src/websocket/client.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst types_1 = require(\"./types\");\nconst token_1 = require(\"./token\");\nconst StartEventJSON = JSON.stringify({ event: 'start' });\nconst StopEventJSON = JSON.stringify({ event: 'stop' });\nclass WebsocketClient {\n    constructor(loginUrl, apiUrl, languageCode, sampleRate) {\n        this.startCbs = [];\n        this.stopCbs = [];\n        this.onResponseCb = () => { };\n        this.onCloseCb = () => { };\n        this.onWebsocketMessage = (event) => {\n            let response;\n            try {\n                response = JSON.parse(event.data);\n            }\n            catch (e) {\n                console.error('[SpeechlyClient] Error parsing response from the server:', e);\n                return;\n            }\n            switch (response.type) {\n                case types_1.WebsocketResponseType.Started:\n                    this.startCbs.forEach(cb => {\n                        try {\n                            cb(undefined, response.audio_context);\n                        }\n                        catch (e) {\n                            console.error('[SpeechlyClient] Error while invoking \"onStart\" callback:', e);\n                        }\n                    });\n                    this.startCbs.length = 0;\n                    break;\n                case types_1.WebsocketResponseType.Stopped:\n                    this.stopCbs.forEach(cb => {\n                        try {\n                            cb(undefined, response.audio_context);\n                        }\n                        catch (e) {\n                            console.error('[SpeechlyClient] Error while invoking \"onStop\" callback:', e);\n                        }\n                    });\n                    this.stopCbs.length = 0;\n                    break;\n                default:\n                    this.onResponseCb(response);\n            }\n        };\n        this.onWebsocketClose = (event) => {\n            this.websocket = undefined;\n            this.onCloseCb(Error(`Websocket was closed with code \"${event.code}\" and reason \"${event.reason}\"`));\n        };\n        this.onWebsocketError = (_event) => {\n            this.closeWebsocket(1000, 'Client disconnecting due to an error');\n            this.onCloseCb(Error('Websocket was closed because of error'));\n        };\n        this.loginUrl = loginUrl;\n        this.apiUrl = generateWsUrl(apiUrl, languageCode, sampleRate);\n    }\n    onResponse(cb) {\n        this.onResponseCb = cb;\n    }\n    onClose(cb) {\n        this.onCloseCb = cb;\n    }\n    initialize(appId, deviceId, token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.websocket !== undefined) {\n                throw Error('Cannot initialize an already initialized websocket client');\n            }\n            if (token !== undefined && token_1.validateToken(token, appId, deviceId)) {\n                // If the token is still valid, don't refresh it.\n                this.authToken = token;\n            }\n            else {\n                this.authToken = yield token_1.fetchToken(this.loginUrl, appId, deviceId);\n            }\n            this.websocket = yield initializeWebsocket(this.apiUrl, this.authToken);\n            this.websocket.addEventListener('message', this.onWebsocketMessage);\n            this.websocket.addEventListener('error', this.onWebsocketError);\n            this.websocket.addEventListener('close', this.onWebsocketClose);\n            return this.authToken;\n        });\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.closeWebsocket(1000, 'Client has ended the session');\n        });\n    }\n    startContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isOpen()) {\n                throw Error('Websocket is not ready');\n            }\n            const ws = this.websocket;\n            return new Promise((resolve, reject) => {\n                this.startCbs.push((err, id) => {\n                    if (err !== undefined) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(id);\n                    }\n                });\n                ws.send(StartEventJSON);\n            });\n        });\n    }\n    stopContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isOpen()) {\n                throw Error('Websocket is not ready');\n            }\n            const ws = this.websocket;\n            return new Promise((resolve, reject) => {\n                this.stopCbs.push((err, id) => {\n                    if (err !== undefined) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(id);\n                    }\n                });\n                ws.send(StopEventJSON);\n            });\n        });\n    }\n    sendAudio(audioChunk) {\n        if (!this.isOpen()) {\n            return Error('Cannot send data through inactive websocket');\n        }\n        const ws = this.websocket;\n        ws.send(audioChunk);\n    }\n    isOpen() {\n        return this.websocket !== undefined && this.websocket.readyState === this.websocket.OPEN;\n    }\n    closeWebsocket(code, message) {\n        if (this.websocket === undefined) {\n            throw Error('Websocket is not open');\n        }\n        this.websocket.removeEventListener('message', this.onWebsocketMessage);\n        this.websocket.removeEventListener('error', this.onWebsocketError);\n        this.websocket.removeEventListener('close', this.onWebsocketClose);\n        this.websocket.close(code, message);\n        this.websocket = undefined;\n    }\n}\nexports.WebsocketClient = WebsocketClient;\nfunction generateWsUrl(baseUrl, languageCode, sampleRate) {\n    const params = new URLSearchParams();\n    params.append('languageCode', languageCode);\n    params.append('sampleRate', sampleRate.toString());\n    return `${baseUrl}?${params.toString()}`;\n}\nfunction initializeWebsocket(url, protocol) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const ws = new WebSocket(url, protocol);\n        return new Promise((resolve, reject) => {\n            const errhandler = () => {\n                ws.removeEventListener('close', errhandler);\n                ws.removeEventListener('error', errhandler);\n                ws.removeEventListener('open', openhandler);\n                reject(Error('Connection failed'));\n            };\n            const openhandler = () => {\n                ws.removeEventListener('close', errhandler);\n                ws.removeEventListener('error', errhandler);\n                ws.removeEventListener('open', openhandler);\n                resolve(ws);\n            };\n            ws.addEventListener('close', errhandler);\n            ws.addEventListener('error', errhandler);\n            ws.addEventListener('open', openhandler);\n        });\n    });\n}\n//# sourceMappingURL=client.js.map"]},"metadata":{},"sourceType":"script"}