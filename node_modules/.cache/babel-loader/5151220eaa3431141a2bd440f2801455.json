{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst emptyBuffer = new Float32Array(0);\n\nfunction newSampler(sourceSampleRate, targetSampleRate) {\n  if (sourceSampleRate === targetSampleRate) {\n    return new BypassSampler();\n  } else if (sourceSampleRate > targetSampleRate) {\n    return new DownSampler(sourceSampleRate, targetSampleRate, generateFilter(sourceSampleRate, targetSampleRate, 127));\n  } else {\n    throw Error('Upsampling is not supported!');\n  }\n}\n\nexports.newSampler = newSampler;\n/**\n * BypassSampler is a re-sampler that simply returns the passed buffer without performing any sampling.\n */\n\nclass BypassSampler {\n  constructor() {\n    this.resampleRatio = 1;\n  }\n\n  call(input) {\n    return float32ToInt16(input);\n  }\n\n}\n\nexports.BypassSampler = BypassSampler;\n/**\n * DownSampler is a re-sampler that performs downsampling on the passed audio buffer.\n */\n\nclass DownSampler {\n  constructor(sourceSampleRate, targetSampleRate, filter) {\n    this.buffer = emptyBuffer;\n    this.resampleRatio = sourceSampleRate / targetSampleRate;\n    this.filter = filter;\n  }\n\n  call(input) {\n    const inputBuffer = new Float32Array(this.buffer.length + input.length);\n    inputBuffer.set(this.buffer, 0);\n    inputBuffer.set(input, this.buffer.length);\n    const outputLength = Math.ceil((inputBuffer.length - this.filter.length) / this.resampleRatio);\n    const outputBuffer = new Int16Array(outputLength);\n\n    for (let i = 0; i < outputLength; i++) {\n      const offset = Math.round(this.resampleRatio * i);\n      let val = 0.0;\n\n      for (let j = 0; j < this.filter.length; j++) {\n        val += inputBuffer[offset + j] * this.filter[j];\n      }\n\n      outputBuffer[i] = val * (val < 0 ? 0x8000 : 0x7fff);\n    }\n\n    const remainingOffset = Math.round(this.resampleRatio * outputLength);\n\n    if (remainingOffset < inputBuffer.length) {\n      this.buffer = inputBuffer.subarray(remainingOffset);\n    } else {\n      this.buffer = emptyBuffer;\n    }\n\n    return outputBuffer;\n  }\n\n}\n\nexports.DownSampler = DownSampler;\n\nfunction float32ToInt16(buffer) {\n  const buf = new Int16Array(buffer.length);\n\n  for (let l = 0; l < buffer.length; l++) {\n    buf[l] = buffer[l] * (buffer[l] < 0 ? 0x8000 : 0x7fff);\n  }\n\n  return buf;\n}\n\nfunction generateFilter(sourceSampleRate, targetSampleRate, length) {\n  if (length % 2 === 0) {\n    throw Error('Filter length must be odd');\n  }\n\n  const cutoff = targetSampleRate / 2;\n  const filter = new Float32Array(length);\n  let sum = 0;\n\n  for (let i = 0; i < length; i++) {\n    const x = sinc(2 * cutoff / sourceSampleRate * (i - (length - 1) / 2));\n    sum += x;\n    filter[i] = x;\n  }\n\n  for (let i = 0; i < length; i++) {\n    filter[i] = filter[i] / sum;\n  }\n\n  return filter;\n}\n\nfunction sinc(x) {\n  if (x === 0.0) {\n    return 1.0;\n  }\n\n  const piX = Math.PI * x;\n  return Math.sin(piX) / piX;\n}","map":{"version":3,"sources":["../../src/microphone/sampler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst emptyBuffer = new Float32Array(0);\nfunction newSampler(sourceSampleRate, targetSampleRate) {\n    if (sourceSampleRate === targetSampleRate) {\n        return new BypassSampler();\n    }\n    else if (sourceSampleRate > targetSampleRate) {\n        return new DownSampler(sourceSampleRate, targetSampleRate, generateFilter(sourceSampleRate, targetSampleRate, 127));\n    }\n    else {\n        throw Error('Upsampling is not supported!');\n    }\n}\nexports.newSampler = newSampler;\n/**\n * BypassSampler is a re-sampler that simply returns the passed buffer without performing any sampling.\n */\nclass BypassSampler {\n    constructor() {\n        this.resampleRatio = 1;\n    }\n    call(input) {\n        return float32ToInt16(input);\n    }\n}\nexports.BypassSampler = BypassSampler;\n/**\n * DownSampler is a re-sampler that performs downsampling on the passed audio buffer.\n */\nclass DownSampler {\n    constructor(sourceSampleRate, targetSampleRate, filter) {\n        this.buffer = emptyBuffer;\n        this.resampleRatio = sourceSampleRate / targetSampleRate;\n        this.filter = filter;\n    }\n    call(input) {\n        const inputBuffer = new Float32Array(this.buffer.length + input.length);\n        inputBuffer.set(this.buffer, 0);\n        inputBuffer.set(input, this.buffer.length);\n        const outputLength = Math.ceil((inputBuffer.length - this.filter.length) / this.resampleRatio);\n        const outputBuffer = new Int16Array(outputLength);\n        for (let i = 0; i < outputLength; i++) {\n            const offset = Math.round(this.resampleRatio * i);\n            let val = 0.0;\n            for (let j = 0; j < this.filter.length; j++) {\n                val += inputBuffer[offset + j] * this.filter[j];\n            }\n            outputBuffer[i] = val * (val < 0 ? 0x8000 : 0x7fff);\n        }\n        const remainingOffset = Math.round(this.resampleRatio * outputLength);\n        if (remainingOffset < inputBuffer.length) {\n            this.buffer = inputBuffer.subarray(remainingOffset);\n        }\n        else {\n            this.buffer = emptyBuffer;\n        }\n        return outputBuffer;\n    }\n}\nexports.DownSampler = DownSampler;\nfunction float32ToInt16(buffer) {\n    const buf = new Int16Array(buffer.length);\n    for (let l = 0; l < buffer.length; l++) {\n        buf[l] = buffer[l] * (buffer[l] < 0 ? 0x8000 : 0x7fff);\n    }\n    return buf;\n}\nfunction generateFilter(sourceSampleRate, targetSampleRate, length) {\n    if (length % 2 === 0) {\n        throw Error('Filter length must be odd');\n    }\n    const cutoff = targetSampleRate / 2;\n    const filter = new Float32Array(length);\n    let sum = 0;\n    for (let i = 0; i < length; i++) {\n        const x = sinc(((2 * cutoff) / sourceSampleRate) * (i - (length - 1) / 2));\n        sum += x;\n        filter[i] = x;\n    }\n    for (let i = 0; i < length; i++) {\n        filter[i] = filter[i] / sum;\n    }\n    return filter;\n}\nfunction sinc(x) {\n    if (x === 0.0) {\n        return 1.0;\n    }\n    const piX = Math.PI * x;\n    return Math.sin(piX) / piX;\n}\n//# sourceMappingURL=sampler.js.map"]},"metadata":{},"sourceType":"script"}