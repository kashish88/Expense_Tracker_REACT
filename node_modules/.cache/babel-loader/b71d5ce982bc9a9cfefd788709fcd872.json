{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst locale_code_1 = __importDefault(require(\"locale-code\"));\n\nconst uuid_1 = require(\"uuid\");\n\nconst microphone_1 = require(\"../microphone\");\n\nconst websocket_1 = require(\"../websocket\");\n\nconst storage_1 = require(\"../storage\");\n\nconst types_1 = require(\"./types\");\n\nconst state_1 = require(\"./state\");\n\nconst segment_1 = require(\"./segment\");\n\nconst parsers_1 = require(\"./parsers\");\n\nconst async_retry_1 = __importDefault(require(\"async-retry\"));\n\nconst deviceIdStorageKey = 'speechly-device-id';\nconst authTokenKey = 'speechly-auth-token';\nconst defaultApiUrl = 'wss://api.speechly.com/ws/v1';\nconst defaultLoginUrl = 'https://api.speechly.com/login';\nconst defaultLanguage = 'en-US';\n/**\n * A client for Speechly Spoken Language Understanding (SLU) API. The client handles initializing the microphone\n * and websocket connection to Speechly API, passing control events and audio stream to the API, reading the responses\n * and dispatching them, as well as providing a high-level API for interacting with so-called speech segments.\n * @public\n */\n\nclass Client {\n  constructor(options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n    this.activeContexts = new Map();\n    this.reconnectAttemptCount = 5;\n    this.reconnectMinDelay = 1000;\n    this.contextStopDelay = 250;\n    this.state = types_1.ClientState.Disconnected;\n\n    this.stateChangeCb = () => {};\n\n    this.segmentChangeCb = () => {};\n\n    this.tentativeTranscriptCb = () => {};\n\n    this.tentativeEntitiesCb = () => {};\n\n    this.tentativeIntentCb = () => {};\n\n    this.transcriptCb = () => {};\n\n    this.entityCb = () => {};\n\n    this.intentCb = () => {};\n\n    this.handleWebsocketResponse = response => {\n      var _a;\n\n      if (this.debug) {\n        console.log('[SpeechlyClient]', 'Received response', response);\n      } // eslint-disable-next-line @typescript-eslint/camelcase\n\n\n      const {\n        audio_context,\n        segment_id,\n        type\n      } = response;\n      let {\n        data\n      } = response;\n      const context = this.activeContexts.get(audio_context);\n\n      if (context === undefined) {\n        console.warn('[SpeechlyClient]', 'Received response for non-existent context', audio_context);\n        return;\n      }\n\n      let segmentState = (_a = context.get(segment_id)) !== null && _a !== void 0 ? _a : new segment_1.SegmentState(audio_context, segment_id);\n\n      switch (type) {\n        case websocket_1.WebsocketResponseType.TentativeTranscript:\n          data = data;\n          const words = parsers_1.parseTentativeTranscript(data);\n          this.tentativeTranscriptCb(audio_context, segment_id, words, data.transcript);\n          segmentState = segmentState.updateTranscript(words);\n          break;\n\n        case websocket_1.WebsocketResponseType.Transcript:\n          data = data;\n          const word = parsers_1.parseTranscript(data);\n          this.transcriptCb(audio_context, segment_id, word);\n          segmentState = segmentState.updateTranscript([word]);\n          break;\n\n        case websocket_1.WebsocketResponseType.TentativeEntities:\n          data = data;\n          const entities = parsers_1.parseTentativeEntities(data);\n          this.tentativeEntitiesCb(audio_context, segment_id, entities);\n          segmentState = segmentState.updateEntities(entities);\n          break;\n\n        case websocket_1.WebsocketResponseType.Entity:\n          data = data;\n          const entity = parsers_1.parseEntity(data);\n          this.entityCb(audio_context, segment_id, entity);\n          segmentState = segmentState.updateEntities([entity]);\n          break;\n\n        case websocket_1.WebsocketResponseType.TentativeIntent:\n          data = data;\n          const tentativeIntent = parsers_1.parseIntent(data, false);\n          this.tentativeIntentCb(audio_context, segment_id, tentativeIntent);\n          segmentState = segmentState.updateIntent(tentativeIntent);\n          break;\n\n        case websocket_1.WebsocketResponseType.Intent:\n          data = data;\n          const intent = parsers_1.parseIntent(data, true);\n          this.intentCb(audio_context, segment_id, intent);\n          segmentState = segmentState.updateIntent(intent);\n          break;\n\n        case websocket_1.WebsocketResponseType.SegmentEnd:\n          segmentState = segmentState.finalize();\n          break;\n\n        default: // TODO: handle unexpected response types.\n\n      } // Update the segment in current context.\n\n\n      context.set(segment_id, segmentState); // Update current contexts.\n\n      this.activeContexts.set(audio_context, context); // Fire segment change event.\n\n      this.segmentChangeCb(segmentState.toSegment());\n    };\n\n    this.handleWebsocketClosure = err => {\n      if (this.debug) {\n        console.error('[SpeechlyClient]', 'Server connection closed', err);\n      } // If for some reason deviceId is missing, there's nothing else we can do but fail completely.\n\n\n      if (this.deviceId === undefined) {\n        this.setState(types_1.ClientState.Failed);\n        return;\n      } // Make sure we don't have concurrent reconnection procedures or attempt to reconnect from a failed state.\n\n\n      if (this.state === types_1.ClientState.Connecting || this.state === types_1.ClientState.Failed) {\n        return;\n      }\n\n      this.setState(types_1.ClientState.Connecting);\n      this.reconnectWebsocket(this.deviceId).then(() => this.setState(types_1.ClientState.Connected)).catch(() => this.setState(types_1.ClientState.Failed));\n    };\n\n    this.handleMicrophoneAudio = audioChunk => {\n      if (this.state !== types_1.ClientState.Recording) {\n        return;\n      }\n\n      this.websocket.sendAudio(audioChunk);\n    };\n\n    const language = (_a = options.language) !== null && _a !== void 0 ? _a : defaultLanguage;\n\n    if (!locale_code_1.default.validate(language)) {\n      throw Error(`[SpeechlyClient] Invalid language \"${language}\"`);\n    }\n\n    this.debug = (_b = options.debug) !== null && _b !== void 0 ? _b : false;\n    this.appId = options.appId;\n    this.microphone = (_c = options.microphone) !== null && _c !== void 0 ? _c : new microphone_1.BrowserMicrophone((_d = options.sampleRate) !== null && _d !== void 0 ? _d : microphone_1.DefaultSampleRate);\n    this.websocket = (_e = options.apiClient) !== null && _e !== void 0 ? _e : new websocket_1.WebsocketClient((_f = options.loginUrl) !== null && _f !== void 0 ? _f : defaultLoginUrl, (_g = options.apiUrl) !== null && _g !== void 0 ? _g : defaultApiUrl, language, (_h = options.sampleRate) !== null && _h !== void 0 ? _h : microphone_1.DefaultSampleRate);\n    this.storage = (_j = options.storage) !== null && _j !== void 0 ? _j : new storage_1.LocalStorage();\n    this.microphone.onAudio(this.handleMicrophoneAudio);\n    this.websocket.onResponse(this.handleWebsocketResponse);\n    this.websocket.onClose(this.handleWebsocketClosure);\n  }\n  /**\n   * Initializes the client, by initializing the microphone and establishing connection to the API.\n   *\n   * This function HAS to be invoked by a user by e.g. binding it to a button press,\n   * or some other user-performed action.\n   *\n   * If this function is invoked without a user interaction,\n   * the microphone functionality will not work due to security restrictions by the browser.\n   */\n\n\n  initialize() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.state !== types_1.ClientState.Disconnected) {\n        throw Error('Cannot initialize client - client is not in Disconnected state');\n      }\n\n      this.setState(types_1.ClientState.Connecting);\n\n      try {\n        // 1. Initialise the storage and fetch deviceId (or generate new one and store it).\n        yield this.storage.initialize();\n        this.deviceId = yield this.storage.getOrSet(deviceIdStorageKey, uuid_1.v4); // 2. Fetch auth token. It doesn't matter if it's not present.\n\n        try {\n          this.authToken = yield this.storage.get(authTokenKey);\n        } catch (err) {\n          if (this.debug) {\n            console.warn('[SpeechlyClient]', 'Error fetching auth token from storage:', err);\n          }\n        } // 2. Initialise the microphone stack.\n\n\n        yield this.microphone.initialize(); // 3. Initialise websocket.\n\n        yield this.initializeWebsocket(this.deviceId);\n      } catch (err) {\n        switch (err) {\n          case microphone_1.ErrDeviceNotSupported:\n            this.setState(types_1.ClientState.NoBrowserSupport);\n            break;\n\n          case microphone_1.ErrNoAudioConsent:\n            this.setState(types_1.ClientState.NoAudioConsent);\n            break;\n\n          default:\n            this.setState(types_1.ClientState.Failed);\n        }\n\n        throw err;\n      }\n\n      this.setState(types_1.ClientState.Connected);\n    });\n  }\n  /**\n   * Closes the client by closing the API connection and disabling the microphone.\n   */\n\n\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const errs = [];\n\n      try {\n        yield this.storage.close();\n      } catch (err) {\n        errs.push(err.message);\n      }\n\n      try {\n        yield this.microphone.close();\n      } catch (err) {\n        errs.push(err.message);\n      }\n\n      try {\n        yield this.websocket.close();\n      } catch (err) {\n        errs.push(err.message);\n      }\n\n      this.activeContexts.clear();\n      this.setState(types_1.ClientState.Disconnected);\n\n      if (errs.length > 0) {\n        throw Error(errs.join(','));\n      }\n    });\n  }\n  /**\n   * Starts a new SLU context by sending a start context event to the API and unmuting the microphone.\n   * @param cb - the callback which is invoked when the context start was acknowledged by the API.\n   */\n\n\n  startContext() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.resolveStopContext != null) {\n        this.resolveStopContext();\n        yield this.stoppedContextIdPromise;\n      }\n\n      if (this.state !== types_1.ClientState.Connected) {\n        throw Error('Cannot start context - client is not connected');\n      }\n\n      this.setState(types_1.ClientState.Starting);\n      let contextId;\n\n      try {\n        contextId = yield this.websocket.startContext();\n      } catch (err) {\n        this.setState(types_1.ClientState.Connected);\n        throw err;\n      }\n\n      this.setState(types_1.ClientState.Recording);\n      this.microphone.unmute();\n      this.activeContexts.set(contextId, new Map());\n      return contextId;\n    });\n  }\n  /**\n   * Stops current SLU context by sending a stop context event to the API and muting the microphone\n   * delayed by contextStopDelay = 250 ms\n   */\n\n\n  stopContext() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.state !== types_1.ClientState.Recording) {\n        throw Error('Cannot stop context - client is not recording');\n      }\n\n      this.setState(types_1.ClientState.Stopping);\n      this.stoppedContextIdPromise = new Promise(resolve => {\n        Promise.race([new Promise(resolve => setTimeout(resolve, this.contextStopDelay)), new Promise(resolve => {\n          this.resolveStopContext = resolve;\n        })]).then(() => {\n          this._stopContext().then(id => {\n            resolve(id);\n          }).catch(err => {\n            throw err;\n          });\n        }).catch(err => {\n          throw err;\n        });\n      });\n      const contextId = yield this.stoppedContextIdPromise;\n      this.setState(types_1.ClientState.Connected);\n      this.activeContexts.delete(contextId);\n      return contextId;\n    });\n  }\n\n  _stopContext() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.microphone.mute();\n      let contextId;\n\n      try {\n        contextId = yield this.websocket.stopContext();\n      } catch (err) {\n        this.setState(types_1.ClientState.Failed);\n        throw err;\n      }\n\n      return contextId;\n    });\n  }\n  /**\n   * Adds a listener for client state change events.\n   * @param cb - the callback to invoke on state change events.\n   */\n\n\n  onStateChange(cb) {\n    this.stateChangeCb = cb;\n  }\n  /**\n   * Adds a listener for current segment change events.\n   * @param cb - the callback to invoke on segment change events.\n   */\n\n\n  onSegmentChange(cb) {\n    this.segmentChangeCb = cb;\n  }\n  /**\n   * Adds a listener for tentative transcript responses from the API.\n   * @param cb - the callback to invoke on a tentative transcript response.\n   */\n\n\n  onTentativeTranscript(cb) {\n    this.tentativeTranscriptCb = cb;\n  }\n  /**\n   * Adds a listener for transcript responses from the API.\n   * @param cb - the callback to invoke on a transcript response.\n   */\n\n\n  onTranscript(cb) {\n    this.transcriptCb = cb;\n  }\n  /**\n   * Adds a listener for tentative entities responses from the API.\n   * @param cb - the callback to invoke on a tentative entities response.\n   */\n\n\n  onTentativeEntities(cb) {\n    this.tentativeEntitiesCb = cb;\n  }\n  /**\n   * Adds a listener for entity responses from the API.\n   * @param cb - the callback to invoke on an entity response.\n   */\n\n\n  onEntity(cb) {\n    this.entityCb = cb;\n  }\n  /**\n   * Adds a listener for tentative intent responses from the API.\n   * @param cb - the callback to invoke on a tentative intent response.\n   */\n\n\n  onTentativeIntent(cb) {\n    this.tentativeIntentCb = cb;\n  }\n  /**\n   * Adds a listener for intent responses from the API.\n   * @param cb - the callback to invoke on an intent response.\n   */\n\n\n  onIntent(cb) {\n    this.intentCb = cb;\n  }\n\n  reconnectWebsocket(deviceId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return async_retry_1.default((_, attempt) => __awaiter(this, void 0, void 0, function* () {\n        if (this.debug) {\n          console.log('[SpeechlyClient]', 'WebSocket reconnection attempt number:', attempt);\n        }\n\n        yield this.initializeWebsocket(deviceId);\n      }), {\n        retries: this.reconnectAttemptCount,\n        minTimeout: this.reconnectMinDelay\n      });\n    });\n  }\n\n  initializeWebsocket(deviceId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Initialise websocket and save the auth token.\n      this.authToken = yield this.websocket.initialize(this.appId, deviceId, this.authToken); // Cache the auth token in local storage for future use.\n\n      try {\n        yield this.storage.set(authTokenKey, this.authToken);\n      } catch (err) {\n        // No need to fail if the token caching failed, we will just re-fetch it next time.\n        if (this.debug) {\n          console.warn('[SpeechlyClient]', 'Error caching auth token in storage:', err);\n        }\n      }\n    });\n  }\n\n  setState(newState) {\n    if (this.state === newState) {\n      return;\n    }\n\n    if (this.debug) {\n      console.log('[SpeechlyClient]', 'State transition', state_1.stateToString(this.state), state_1.stateToString(newState));\n    }\n\n    this.state = newState;\n    this.stateChangeCb(newState);\n  }\n\n}\n\nexports.Client = Client;","map":{"version":3,"sources":["../../src/speechly/client.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst locale_code_1 = __importDefault(require(\"locale-code\"));\nconst uuid_1 = require(\"uuid\");\nconst microphone_1 = require(\"../microphone\");\nconst websocket_1 = require(\"../websocket\");\nconst storage_1 = require(\"../storage\");\nconst types_1 = require(\"./types\");\nconst state_1 = require(\"./state\");\nconst segment_1 = require(\"./segment\");\nconst parsers_1 = require(\"./parsers\");\nconst async_retry_1 = __importDefault(require(\"async-retry\"));\nconst deviceIdStorageKey = 'speechly-device-id';\nconst authTokenKey = 'speechly-auth-token';\nconst defaultApiUrl = 'wss://api.speechly.com/ws/v1';\nconst defaultLoginUrl = 'https://api.speechly.com/login';\nconst defaultLanguage = 'en-US';\n/**\n * A client for Speechly Spoken Language Understanding (SLU) API. The client handles initializing the microphone\n * and websocket connection to Speechly API, passing control events and audio stream to the API, reading the responses\n * and dispatching them, as well as providing a high-level API for interacting with so-called speech segments.\n * @public\n */\nclass Client {\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        this.activeContexts = new Map();\n        this.reconnectAttemptCount = 5;\n        this.reconnectMinDelay = 1000;\n        this.contextStopDelay = 250;\n        this.state = types_1.ClientState.Disconnected;\n        this.stateChangeCb = () => { };\n        this.segmentChangeCb = () => { };\n        this.tentativeTranscriptCb = () => { };\n        this.tentativeEntitiesCb = () => { };\n        this.tentativeIntentCb = () => { };\n        this.transcriptCb = () => { };\n        this.entityCb = () => { };\n        this.intentCb = () => { };\n        this.handleWebsocketResponse = (response) => {\n            var _a;\n            if (this.debug) {\n                console.log('[SpeechlyClient]', 'Received response', response);\n            }\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            const { audio_context, segment_id, type } = response;\n            let { data } = response;\n            const context = this.activeContexts.get(audio_context);\n            if (context === undefined) {\n                console.warn('[SpeechlyClient]', 'Received response for non-existent context', audio_context);\n                return;\n            }\n            let segmentState = (_a = context.get(segment_id)) !== null && _a !== void 0 ? _a : new segment_1.SegmentState(audio_context, segment_id);\n            switch (type) {\n                case websocket_1.WebsocketResponseType.TentativeTranscript:\n                    data = data;\n                    const words = parsers_1.parseTentativeTranscript(data);\n                    this.tentativeTranscriptCb(audio_context, segment_id, words, data.transcript);\n                    segmentState = segmentState.updateTranscript(words);\n                    break;\n                case websocket_1.WebsocketResponseType.Transcript:\n                    data = data;\n                    const word = parsers_1.parseTranscript(data);\n                    this.transcriptCb(audio_context, segment_id, word);\n                    segmentState = segmentState.updateTranscript([word]);\n                    break;\n                case websocket_1.WebsocketResponseType.TentativeEntities:\n                    data = data;\n                    const entities = parsers_1.parseTentativeEntities(data);\n                    this.tentativeEntitiesCb(audio_context, segment_id, entities);\n                    segmentState = segmentState.updateEntities(entities);\n                    break;\n                case websocket_1.WebsocketResponseType.Entity:\n                    data = data;\n                    const entity = parsers_1.parseEntity(data);\n                    this.entityCb(audio_context, segment_id, entity);\n                    segmentState = segmentState.updateEntities([entity]);\n                    break;\n                case websocket_1.WebsocketResponseType.TentativeIntent:\n                    data = data;\n                    const tentativeIntent = parsers_1.parseIntent(data, false);\n                    this.tentativeIntentCb(audio_context, segment_id, tentativeIntent);\n                    segmentState = segmentState.updateIntent(tentativeIntent);\n                    break;\n                case websocket_1.WebsocketResponseType.Intent:\n                    data = data;\n                    const intent = parsers_1.parseIntent(data, true);\n                    this.intentCb(audio_context, segment_id, intent);\n                    segmentState = segmentState.updateIntent(intent);\n                    break;\n                case websocket_1.WebsocketResponseType.SegmentEnd:\n                    segmentState = segmentState.finalize();\n                    break;\n                default:\n                // TODO: handle unexpected response types.\n            }\n            // Update the segment in current context.\n            context.set(segment_id, segmentState);\n            // Update current contexts.\n            this.activeContexts.set(audio_context, context);\n            // Fire segment change event.\n            this.segmentChangeCb(segmentState.toSegment());\n        };\n        this.handleWebsocketClosure = (err) => {\n            if (this.debug) {\n                console.error('[SpeechlyClient]', 'Server connection closed', err);\n            }\n            // If for some reason deviceId is missing, there's nothing else we can do but fail completely.\n            if (this.deviceId === undefined) {\n                this.setState(types_1.ClientState.Failed);\n                return;\n            }\n            // Make sure we don't have concurrent reconnection procedures or attempt to reconnect from a failed state.\n            if (this.state === types_1.ClientState.Connecting || this.state === types_1.ClientState.Failed) {\n                return;\n            }\n            this.setState(types_1.ClientState.Connecting);\n            this.reconnectWebsocket(this.deviceId)\n                .then(() => this.setState(types_1.ClientState.Connected))\n                .catch(() => this.setState(types_1.ClientState.Failed));\n        };\n        this.handleMicrophoneAudio = (audioChunk) => {\n            if (this.state !== types_1.ClientState.Recording) {\n                return;\n            }\n            this.websocket.sendAudio(audioChunk);\n        };\n        const language = (_a = options.language) !== null && _a !== void 0 ? _a : defaultLanguage;\n        if (!locale_code_1.default.validate(language)) {\n            throw Error(`[SpeechlyClient] Invalid language \"${language}\"`);\n        }\n        this.debug = (_b = options.debug) !== null && _b !== void 0 ? _b : false;\n        this.appId = options.appId;\n        this.microphone = (_c = options.microphone) !== null && _c !== void 0 ? _c : new microphone_1.BrowserMicrophone((_d = options.sampleRate) !== null && _d !== void 0 ? _d : microphone_1.DefaultSampleRate);\n        this.websocket = (_e = options.apiClient) !== null && _e !== void 0 ? _e : new websocket_1.WebsocketClient((_f = options.loginUrl) !== null && _f !== void 0 ? _f : defaultLoginUrl, (_g = options.apiUrl) !== null && _g !== void 0 ? _g : defaultApiUrl, language, (_h = options.sampleRate) !== null && _h !== void 0 ? _h : microphone_1.DefaultSampleRate);\n        this.storage = (_j = options.storage) !== null && _j !== void 0 ? _j : new storage_1.LocalStorage();\n        this.microphone.onAudio(this.handleMicrophoneAudio);\n        this.websocket.onResponse(this.handleWebsocketResponse);\n        this.websocket.onClose(this.handleWebsocketClosure);\n    }\n    /**\n     * Initializes the client, by initializing the microphone and establishing connection to the API.\n     *\n     * This function HAS to be invoked by a user by e.g. binding it to a button press,\n     * or some other user-performed action.\n     *\n     * If this function is invoked without a user interaction,\n     * the microphone functionality will not work due to security restrictions by the browser.\n     */\n    initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.state !== types_1.ClientState.Disconnected) {\n                throw Error('Cannot initialize client - client is not in Disconnected state');\n            }\n            this.setState(types_1.ClientState.Connecting);\n            try {\n                // 1. Initialise the storage and fetch deviceId (or generate new one and store it).\n                yield this.storage.initialize();\n                this.deviceId = yield this.storage.getOrSet(deviceIdStorageKey, uuid_1.v4);\n                // 2. Fetch auth token. It doesn't matter if it's not present.\n                try {\n                    this.authToken = yield this.storage.get(authTokenKey);\n                }\n                catch (err) {\n                    if (this.debug) {\n                        console.warn('[SpeechlyClient]', 'Error fetching auth token from storage:', err);\n                    }\n                }\n                // 2. Initialise the microphone stack.\n                yield this.microphone.initialize();\n                // 3. Initialise websocket.\n                yield this.initializeWebsocket(this.deviceId);\n            }\n            catch (err) {\n                switch (err) {\n                    case microphone_1.ErrDeviceNotSupported:\n                        this.setState(types_1.ClientState.NoBrowserSupport);\n                        break;\n                    case microphone_1.ErrNoAudioConsent:\n                        this.setState(types_1.ClientState.NoAudioConsent);\n                        break;\n                    default:\n                        this.setState(types_1.ClientState.Failed);\n                }\n                throw err;\n            }\n            this.setState(types_1.ClientState.Connected);\n        });\n    }\n    /**\n     * Closes the client by closing the API connection and disabling the microphone.\n     */\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const errs = [];\n            try {\n                yield this.storage.close();\n            }\n            catch (err) {\n                errs.push(err.message);\n            }\n            try {\n                yield this.microphone.close();\n            }\n            catch (err) {\n                errs.push(err.message);\n            }\n            try {\n                yield this.websocket.close();\n            }\n            catch (err) {\n                errs.push(err.message);\n            }\n            this.activeContexts.clear();\n            this.setState(types_1.ClientState.Disconnected);\n            if (errs.length > 0) {\n                throw Error(errs.join(','));\n            }\n        });\n    }\n    /**\n     * Starts a new SLU context by sending a start context event to the API and unmuting the microphone.\n     * @param cb - the callback which is invoked when the context start was acknowledged by the API.\n     */\n    startContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.resolveStopContext != null) {\n                this.resolveStopContext();\n                yield this.stoppedContextIdPromise;\n            }\n            if (this.state !== types_1.ClientState.Connected) {\n                throw Error('Cannot start context - client is not connected');\n            }\n            this.setState(types_1.ClientState.Starting);\n            let contextId;\n            try {\n                contextId = yield this.websocket.startContext();\n            }\n            catch (err) {\n                this.setState(types_1.ClientState.Connected);\n                throw err;\n            }\n            this.setState(types_1.ClientState.Recording);\n            this.microphone.unmute();\n            this.activeContexts.set(contextId, new Map());\n            return contextId;\n        });\n    }\n    /**\n     * Stops current SLU context by sending a stop context event to the API and muting the microphone\n     * delayed by contextStopDelay = 250 ms\n     */\n    stopContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.state !== types_1.ClientState.Recording) {\n                throw Error('Cannot stop context - client is not recording');\n            }\n            this.setState(types_1.ClientState.Stopping);\n            this.stoppedContextIdPromise = new Promise((resolve) => {\n                Promise.race([\n                    new Promise((resolve) => setTimeout(resolve, this.contextStopDelay)),\n                    new Promise((resolve) => { this.resolveStopContext = resolve; }),\n                ])\n                    .then(() => {\n                    this._stopContext()\n                        .then(id => { resolve(id); })\n                        .catch(err => { throw err; });\n                })\n                    .catch(err => { throw err; });\n            });\n            const contextId = yield this.stoppedContextIdPromise;\n            this.setState(types_1.ClientState.Connected);\n            this.activeContexts.delete(contextId);\n            return contextId;\n        });\n    }\n    _stopContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.microphone.mute();\n            let contextId;\n            try {\n                contextId = yield this.websocket.stopContext();\n            }\n            catch (err) {\n                this.setState(types_1.ClientState.Failed);\n                throw err;\n            }\n            return contextId;\n        });\n    }\n    /**\n     * Adds a listener for client state change events.\n     * @param cb - the callback to invoke on state change events.\n     */\n    onStateChange(cb) {\n        this.stateChangeCb = cb;\n    }\n    /**\n     * Adds a listener for current segment change events.\n     * @param cb - the callback to invoke on segment change events.\n     */\n    onSegmentChange(cb) {\n        this.segmentChangeCb = cb;\n    }\n    /**\n     * Adds a listener for tentative transcript responses from the API.\n     * @param cb - the callback to invoke on a tentative transcript response.\n     */\n    onTentativeTranscript(cb) {\n        this.tentativeTranscriptCb = cb;\n    }\n    /**\n     * Adds a listener for transcript responses from the API.\n     * @param cb - the callback to invoke on a transcript response.\n     */\n    onTranscript(cb) {\n        this.transcriptCb = cb;\n    }\n    /**\n     * Adds a listener for tentative entities responses from the API.\n     * @param cb - the callback to invoke on a tentative entities response.\n     */\n    onTentativeEntities(cb) {\n        this.tentativeEntitiesCb = cb;\n    }\n    /**\n     * Adds a listener for entity responses from the API.\n     * @param cb - the callback to invoke on an entity response.\n     */\n    onEntity(cb) {\n        this.entityCb = cb;\n    }\n    /**\n     * Adds a listener for tentative intent responses from the API.\n     * @param cb - the callback to invoke on a tentative intent response.\n     */\n    onTentativeIntent(cb) {\n        this.tentativeIntentCb = cb;\n    }\n    /**\n     * Adds a listener for intent responses from the API.\n     * @param cb - the callback to invoke on an intent response.\n     */\n    onIntent(cb) {\n        this.intentCb = cb;\n    }\n    reconnectWebsocket(deviceId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return async_retry_1.default((_, attempt) => __awaiter(this, void 0, void 0, function* () {\n                if (this.debug) {\n                    console.log('[SpeechlyClient]', 'WebSocket reconnection attempt number:', attempt);\n                }\n                yield this.initializeWebsocket(deviceId);\n            }), {\n                retries: this.reconnectAttemptCount,\n                minTimeout: this.reconnectMinDelay,\n            });\n        });\n    }\n    initializeWebsocket(deviceId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Initialise websocket and save the auth token.\n            this.authToken = yield this.websocket.initialize(this.appId, deviceId, this.authToken);\n            // Cache the auth token in local storage for future use.\n            try {\n                yield this.storage.set(authTokenKey, this.authToken);\n            }\n            catch (err) {\n                // No need to fail if the token caching failed, we will just re-fetch it next time.\n                if (this.debug) {\n                    console.warn('[SpeechlyClient]', 'Error caching auth token in storage:', err);\n                }\n            }\n        });\n    }\n    setState(newState) {\n        if (this.state === newState) {\n            return;\n        }\n        if (this.debug) {\n            console.log('[SpeechlyClient]', 'State transition', state_1.stateToString(this.state), state_1.stateToString(newState));\n        }\n        this.state = newState;\n        this.stateChangeCb(newState);\n    }\n}\nexports.Client = Client;\n//# sourceMappingURL=client.js.map"]},"metadata":{},"sourceType":"script"}