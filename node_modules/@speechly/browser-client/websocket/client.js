"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const token_1 = require("./token");
const StartEventJSON = JSON.stringify({ event: 'start' });
const StopEventJSON = JSON.stringify({ event: 'stop' });
class WebsocketClient {
    constructor(loginUrl, apiUrl, languageCode, sampleRate) {
        this.startCbs = [];
        this.stopCbs = [];
        this.onResponseCb = () => { };
        this.onCloseCb = () => { };
        this.onWebsocketMessage = (event) => {
            let response;
            try {
                response = JSON.parse(event.data);
            }
            catch (e) {
                console.error('[SpeechlyClient] Error parsing response from the server:', e);
                return;
            }
            switch (response.type) {
                case types_1.WebsocketResponseType.Started:
                    this.startCbs.forEach(cb => {
                        try {
                            cb(undefined, response.audio_context);
                        }
                        catch (e) {
                            console.error('[SpeechlyClient] Error while invoking "onStart" callback:', e);
                        }
                    });
                    this.startCbs.length = 0;
                    break;
                case types_1.WebsocketResponseType.Stopped:
                    this.stopCbs.forEach(cb => {
                        try {
                            cb(undefined, response.audio_context);
                        }
                        catch (e) {
                            console.error('[SpeechlyClient] Error while invoking "onStop" callback:', e);
                        }
                    });
                    this.stopCbs.length = 0;
                    break;
                default:
                    this.onResponseCb(response);
            }
        };
        this.onWebsocketClose = (event) => {
            this.websocket = undefined;
            this.onCloseCb(Error(`Websocket was closed with code "${event.code}" and reason "${event.reason}"`));
        };
        this.onWebsocketError = (_event) => {
            this.closeWebsocket(1000, 'Client disconnecting due to an error');
            this.onCloseCb(Error('Websocket was closed because of error'));
        };
        this.loginUrl = loginUrl;
        this.apiUrl = generateWsUrl(apiUrl, languageCode, sampleRate);
    }
    onResponse(cb) {
        this.onResponseCb = cb;
    }
    onClose(cb) {
        this.onCloseCb = cb;
    }
    initialize(appId, deviceId, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.websocket !== undefined) {
                throw Error('Cannot initialize an already initialized websocket client');
            }
            if (token !== undefined && token_1.validateToken(token, appId, deviceId)) {
                // If the token is still valid, don't refresh it.
                this.authToken = token;
            }
            else {
                this.authToken = yield token_1.fetchToken(this.loginUrl, appId, deviceId);
            }
            this.websocket = yield initializeWebsocket(this.apiUrl, this.authToken);
            this.websocket.addEventListener('message', this.onWebsocketMessage);
            this.websocket.addEventListener('error', this.onWebsocketError);
            this.websocket.addEventListener('close', this.onWebsocketClose);
            return this.authToken;
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.closeWebsocket(1000, 'Client has ended the session');
        });
    }
    startContext() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isOpen()) {
                throw Error('Websocket is not ready');
            }
            const ws = this.websocket;
            return new Promise((resolve, reject) => {
                this.startCbs.push((err, id) => {
                    if (err !== undefined) {
                        reject(err);
                    }
                    else {
                        resolve(id);
                    }
                });
                ws.send(StartEventJSON);
            });
        });
    }
    stopContext() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isOpen()) {
                throw Error('Websocket is not ready');
            }
            const ws = this.websocket;
            return new Promise((resolve, reject) => {
                this.stopCbs.push((err, id) => {
                    if (err !== undefined) {
                        reject(err);
                    }
                    else {
                        resolve(id);
                    }
                });
                ws.send(StopEventJSON);
            });
        });
    }
    sendAudio(audioChunk) {
        if (!this.isOpen()) {
            return Error('Cannot send data through inactive websocket');
        }
        const ws = this.websocket;
        ws.send(audioChunk);
    }
    isOpen() {
        return this.websocket !== undefined && this.websocket.readyState === this.websocket.OPEN;
    }
    closeWebsocket(code, message) {
        if (this.websocket === undefined) {
            throw Error('Websocket is not open');
        }
        this.websocket.removeEventListener('message', this.onWebsocketMessage);
        this.websocket.removeEventListener('error', this.onWebsocketError);
        this.websocket.removeEventListener('close', this.onWebsocketClose);
        this.websocket.close(code, message);
        this.websocket = undefined;
    }
}
exports.WebsocketClient = WebsocketClient;
function generateWsUrl(baseUrl, languageCode, sampleRate) {
    const params = new URLSearchParams();
    params.append('languageCode', languageCode);
    params.append('sampleRate', sampleRate.toString());
    return `${baseUrl}?${params.toString()}`;
}
function initializeWebsocket(url, protocol) {
    return __awaiter(this, void 0, void 0, function* () {
        const ws = new WebSocket(url, protocol);
        return new Promise((resolve, reject) => {
            const errhandler = () => {
                ws.removeEventListener('close', errhandler);
                ws.removeEventListener('error', errhandler);
                ws.removeEventListener('open', openhandler);
                reject(Error('Connection failed'));
            };
            const openhandler = () => {
                ws.removeEventListener('close', errhandler);
                ws.removeEventListener('error', errhandler);
                ws.removeEventListener('open', openhandler);
                resolve(ws);
            };
            ws.addEventListener('close', errhandler);
            ws.addEventListener('error', errhandler);
            ws.addEventListener('open', openhandler);
        });
    });
}
//# sourceMappingURL=client.js.map